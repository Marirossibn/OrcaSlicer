package Slic3r::Layer;
use Moo;

use Slic3r::Geometry::Clipper qw(union_ex);

has 'id'                => (is => 'rw', required => 1); # sequential number of layer, 0-based
has 'materials'         => (is => 'ro', default => sub { [] });
has 'slicing_errors'    => (is => 'rw');

has 'slice_z'           => (is => 'lazy');
has 'print_z'           => (is => 'lazy');
has 'height'            => (is => 'lazy');
has 'flow'              => (is => 'lazy');
has 'perimeter_flow'    => (is => 'lazy');
has 'infill_flow'       => (is => 'lazy');

# collection of surfaces generated by slicing the original geometry;
# also known as 'islands' (all materials are merged here)
has 'slices'            => (is => 'rw');

# ordered collection of extrusion paths to fill surfaces for support material
has 'support_fills'     => (is => 'rw');

# Z used for slicing
sub _build_slice_z {
    my $self = shift;
    
    if ($self->id == 0) {
        return $Slic3r::Config->get_value('first_layer_height') / 2 / &Slic3r::SCALING_FACTOR;
    }
    return ($Slic3r::Config->get_value('first_layer_height') + (($self->id-1) * $Slic3r::Config->layer_height) + ($Slic3r::Config->layer_height/2))
        / &Slic3r::SCALING_FACTOR;  #/
}

# Z used for printing
sub _build_print_z {
    my $self = shift;
    return ($Slic3r::Config->get_value('first_layer_height') + ($self->id * $Slic3r::Config->layer_height)) / &Slic3r::SCALING_FACTOR;
}

sub _build_height {
    my $self = shift;
    return $self->id == 0 ? $Slic3r::Config->get_value('first_layer_height') : $Slic3r::Config->layer_height;
}

sub _build_flow {
    my $self = shift;
    return $self->id == 0 && $Slic3r::first_layer_flow
        ? $Slic3r::first_layer_flow
        : $Slic3r::flow;
}

sub _build_perimeter_flow {
    my $self = shift;
    return $self->id == 0 && $Slic3r::first_layer_flow
        ? $Slic3r::first_layer_flow
        : $Slic3r::perimeter_flow;
}

sub _build_infill_flow {
    my $self = shift;
    return $self->id == 0 && $Slic3r::first_layer_flow
        ? $Slic3r::first_layer_flow
        : $Slic3r::infill_flow;
}

sub material {
    my $self = shift;
    my ($material_idx) = @_;
    
    for my $i (grep !defined $self->materials->[$_], 0..$material_idx) {
        $self->materials->[$i] = Slic3r::Layer::Material->new(
            layer => $self,
        );
    }
    return $self->materials->[$material_idx];
}

# merge all materials' slices to get islands
sub make_slices {
    my $self = shift;
    
    # optimization for single-material layers
    my @materials_with_slices = grep { @{$_->slices} } @{$self->materials};
    if (@materials_with_slices == 1) {
        $self->slices($materials_with_slices[0]->slices);
        return;
    }
    
    $self->slices(union_ex([ map @{$_->slices}, @{$self->materials} ]));
}

sub make_perimeters {
    my $self = shift;
    Slic3r::debugf "Making perimeters for layer %d\n", $self->id;
    $_->make_perimeters for @{$self->materials};
}

1;
