package Slic3r::Layer;
use Moo;

use Math::Clipper ':all';
use Math::ConvexHull qw(convex_hull);
use Slic3r::Geometry qw(polygon_lines points_coincide angle3points polyline_lines);
use XXX;

use constant PI => 4 * atan2(1, 1);
use constant A => 0;
use constant B => 1;

# a sequential number of layer, starting at 0
has 'id' => (
    is          => 'ro',
    #isa         => 'Int',
    required    => 1,
);

# collection of spare segments generated by slicing the original geometry;
# these need to be merged in continuos (closed) polylines
has 'lines' => (
    is      => 'rw',
    #isa     => 'ArrayRef[Slic3r::Line]',
    default => sub { [] },
);

# collection of surfaces generated by slicing the original geometry
has 'surfaces' => (
    is      => 'rw',
    #isa     => 'ArrayRef[Slic3r::Surface]',
    default => sub { [] },
);

# collection of surfaces representing bridges
has 'bridges' => (
    is      => 'rw',
    #isa     => 'ArrayRef[Slic3r::Surface::Bridge]',
    default => sub { [] },
);

# collection of surfaces to make perimeters for
has 'perimeter_surfaces' => (
    is      => 'rw',
    #isa     => 'ArrayRef[Slic3r::Surface]',
    default => sub { [] },
);

# ordered collection of extrusion paths to build all perimeters
has 'perimeters' => (
    is      => 'rw',
    #isa     => 'ArrayRef[Slic3r::ExtrusionLoop]',
    default => sub { [] },
);

# ordered collection of extrusion paths to build skirt loops
has 'skirts' => (
    is      => 'rw',
    #isa     => 'ArrayRef[Slic3r::ExtrusionLoop]',
    default => sub { [] },
);

# collection of surfaces generated by offsetting the innermost perimeter(s)
# they represent boundaries of areas to fill
has 'fill_surfaces' => (
    is      => 'rw',
    #isa     => 'ArrayRef[Slic3r::Surface::Collection]',
    default => sub { [] },
);

# ordered collection of extrusion paths to fill surfaces
has 'fills' => (
    is      => 'rw',
    #isa     => 'ArrayRef[Slic3r::ExtrusionPath]',
    default => sub { [] },
);

sub z {
    my $self = shift;
    return $self->id * $Slic3r::layer_height / $Slic3r::resolution;
}

sub add_surface {
    my $self = shift;
    my (@vertices) = @_;
    
    # convert arrayref points to Point objects
    @vertices = map Slic3r::Point->cast($_), @vertices;
    
    my $surface = Slic3r::Surface->new(
        contour => Slic3r::Polyline::Closed->new(points => \@vertices),
    );
    push @{ $self->surfaces }, $surface;
    
    # make sure our contour has its points in counter-clockwise order
    $surface->contour->make_counter_clockwise;
    
    return $surface;
}

sub add_line {
    my $self = shift;
    my ($line) = @_;
    
    $line = Slic3r::Line->cast($line);
    return if $line->a->coincides_with($line->b);
    
    push @{ $self->lines }, $line;
    return $line;
}

sub remove_line {
    my $self = shift;
    my ($line) = @_;
    @{ $self->lines } = grep $_ ne $line, @{ $self->lines };
}

sub remove_surface {
    my $self = shift;
    my ($surface) = @_;
    @{ $self->surfaces } = grep $_ ne $surface, @{ $self->surfaces };
}

# build polylines of lines which do not already belong to a surface
sub make_polylines {
    my $self = shift;
    
    my @lines = ();
    push @lines, map $_->p, @{$self->lines};
    
    #use Slic3r::SVG;
    #Slic3r::SVG::output(undef, "lines.svg",
    #    lines       => [ map $_->p, grep !$_->isa('Slic3r::Line::FacetEdge'), @{$self->lines} ],
    #    red_lines   => [ map $_->p, grep  $_->isa('Slic3r::Line::FacetEdge'), @{$self->lines} ],
    #);
    
    my $get_point_id = sub { sprintf "%d,%d", @{$_[0]} };
    
    my (%pointmap) = ();
    foreach my $line (@lines) {
        my $point_id = $get_point_id->($line->[A]);
        $pointmap{$point_id} ||= [];
        push @{ $pointmap{$point_id} }, $line;
    }
    
    my $n = 0;
    my @polylines = ();
    while (my $first_line = shift @lines) {
        my @points = @$first_line;
        my %seen_points = map { $get_point_id->($points[$_]) => $_ } 0..1;
        
        CYCLE: while (1) {
            my $next_lines = $pointmap{ $get_point_id->($points[-1]) }
                or die sprintf "No lines start at point %d,%d. This shouldn't happen", @{$points[-1]};
            last CYCLE if !@$next_lines;
            
            my @ordered_next_lines = sort 
                { angle3points($points[-1], $points[-2], $next_lines->[$a][B]) <=> angle3points($points[-1], $points[-2], $next_lines->[$b][B]) } 
                0..$#$next_lines;
            
            #if (@$next_lines > 1) {
            #    Slic3r::SVG::output(undef, "next_line.svg",
            #        lines        => $next_lines,
            #        red_lines    => [ polyline_lines([@points]) ],
            #        green_lines  => [ $next_lines->[ $ordered_next_lines[0] ] ],
            #    );
            #}
            
            my ($next_line) = splice @$next_lines, $ordered_next_lines[0], 1;
            
            
            push @points, $next_line->[B];
            
            my $point_id = $get_point_id->($points[-1]);
            if ($seen_points{$point_id}) {
                splice @points, 0, $seen_points{$point_id};
                last CYCLE;
            }
            
            $seen_points{$point_id} = $#points;
        }
        
        if (@points < 4 || !points_coincide($points[0], $points[-1])) {
            next;
        }
        
        pop @points;
        Slic3r::debugf "Discovered polyline of %d points\n", scalar(@points);
        push @polylines, [@points];
    }
    
    #Slic3r::SVG::output(undef, "polylines.svg",
    #    polylines => [ @polylines ],
    #);
    
    return [ map Slic3r::Polyline::Closed->cast($_), @polylines ];
}

sub make_surfaces {
    my $self = shift;
    my ($polylines) = @_;
    
    #use Slic3r::SVG;
    #Slic3r::SVG::output_polygons($main::print, "polylines.svg", [ map $_->p, @$polylines ]);
    
    # count how many other polylines enclose each polyline
    # even = contour; odd = hole
    my %enclosing_polylines = ();
    my %enclosing_polylines_count = ();
    my $max_depth = 0;
    foreach my $polyline (@$polylines) {
        # a polyline encloses another one if any point of it is enclosed
        # in the other
        my $point = $polyline->points->[0];
        my $ordered_id = $polyline->id;
        
        # find polylines contaning $point, and thus $polyline
        $enclosing_polylines{$polyline} = 
            [ grep $_->id ne $ordered_id && $_->encloses_point($point), @$polylines ];
        $enclosing_polylines_count{$polyline} = scalar @{ $enclosing_polylines{$polyline} };
        
        $max_depth = $enclosing_polylines_count{$polyline}
            if $enclosing_polylines_count{$polyline} > $max_depth;
    }
    
    # make a cache for contours and surfaces
    my %surfaces = ();   # contour => surface
    
    # start looking at most inner polylines
    for (; $max_depth > -1; $max_depth--) {
        foreach my $polyline (@$polylines) {
            next unless $enclosing_polylines_count{$polyline} == $max_depth;
            
            my $surface;
            if ($enclosing_polylines_count{$polyline} % 2 == 0) {
                # this is a contour
                $polyline->make_counter_clockwise;
                $surface = Slic3r::Surface->new(contour => $polyline);
            } else {
                # this is a hole
                $polyline->make_clockwise;
                
                # find the enclosing polyline having immediately close depth
                my ($contour) = grep $enclosing_polylines_count{$_} == ($max_depth-1), 
                    @{ $enclosing_polylines{$polyline} };
                
                if ($surfaces{$contour}) {
                    $surface = $surfaces{$contour};
                    $surface->add_hole($polyline);
                } else {
                    $surface = Slic3r::Surface->new(
                        contour => $contour,
                        holes   => [$polyline],
                    );
                    $surfaces{$contour} = $surface;
                }
            }
            
            # check whether we already have this surface
            next if grep $_->id eq $surface->id, @{ $self->surfaces };
            
            $surface->surface_type('internal');
            push @{ $self->surfaces }, $surface;
            
            Slic3r::debugf "New surface: %s (%d holes: %s)\n", 
                $surface->id, scalar @{$surface->holes},
                join(', ', map $_->id, @{$surface->holes}) || 'none'
                if $Slic3r::debug;
        }
    }
}

sub merge_contiguous_surfaces {
    my $self = shift;
    
    if ($Slic3r::debug) {
        Slic3r::debugf "Initial surfaces (%d):\n", scalar @{ $self->surfaces };
        Slic3r::debugf "  [%s] %s (%s with %d holes)\n", $_->surface_type, $_->id, 
            ($_->contour->is_counter_clockwise ? 'ccw' : 'cw'), scalar @{$_->holes} for @{ $self->surfaces };
        #Slic3r::SVG::output_polygons(undef, "polygons-before.svg", [ map $_->contour->p, @{$self->surfaces} ]);
    }
    
    my %resulting_surfaces = ();
    
    # only merge surfaces with same type
    foreach my $type (qw(bottom top internal)) {
        my $clipper = Math::Clipper->new;
        my @surfaces = grep $_->surface_type eq $type, @{$self->surfaces}
            or next;
        
        #Slic3r::SVG::output_polygons($main::print, "polygons-$type-before.svg", [ map $_->contour->p, @surfaces ]);
        $clipper->add_subject_polygons([ map $_->contour->p, @surfaces ]);
        
        my $result = $clipper->ex_execute(CT_UNION, PFT_NONZERO, PFT_NONZERO);
        $clipper->clear;
        
        my @extra_holes = map @{$_->{holes}}, @$result;
        $result = [ map $_->{outer}, @$result ];
        #Slic3r::SVG::output_polygons($main::print, "polygons-$type-union.svg", $result);
        
        # subtract bottom or top surfaces from internal
        if ($type eq 'internal') {
            $clipper->add_subject_polygons($result);
            $clipper->add_clip_polygons([ map $_->{outer}, @{$resulting_surfaces{$_}} ])
                for qw(bottom top);
            $result = $clipper->execute(CT_DIFFERENCE, PFT_NONZERO, PFT_NONZERO);
            $clipper->clear;
        }
        
        # apply holes
        $clipper->add_subject_polygons($result);
        $result = $clipper->execute(CT_DIFFERENCE, PFT_NONZERO, PFT_NONZERO);
        $clipper->clear;
        
        $clipper->add_subject_polygons($result);
        $clipper->add_clip_polygons([ @extra_holes ]) if @extra_holes;
        $clipper->add_clip_polygons([ map $_->p, map @{$_->holes}, @surfaces ]);
        my $result2 = $clipper->ex_execute(CT_DIFFERENCE, PFT_NONZERO, PFT_NONZERO);
        
        $resulting_surfaces{$type} = $result2;
    }
    
    # remove overlapping surfaces
    # (remove anything that is not internal from areas covered by internal surfaces)
    # this may happen because of rounding of Z coordinates: the model could have
    # features smaller than our layer height, so we'd get more things on a single
    # layer
    if (0) {  # not proven to be necessary until now
        my $clipper = Math::Clipper->new;
        foreach my $type (qw(bottom top)) {
            $clipper->clear;
            $clipper->add_subject_polygons([ map { $_->{outer}, @{$_->{holes}} } @{$resulting_surfaces{$type}} ]);
            $clipper->add_clip_polygons([ map { $_->{outer}, @{$_->{holes}} } @{$resulting_surfaces{internal}} ]);
            $resulting_surfaces{$type} = $clipper->ex_execute(CT_DIFFERENCE, PFT_NONZERO, PFT_NONZERO);
        }
    }
    
    # save surfaces
    @{ $self->surfaces } = ();
    foreach my $type (keys %resulting_surfaces) {
        foreach my $p (@{ $resulting_surfaces{$type} }) {
            push @{ $self->surfaces }, Slic3r::Surface->new(
                surface_type => $type,
                contour => Slic3r::Polyline::Closed->cast($p->{outer}),
                holes   => [
                    map Slic3r::Polyline::Closed->cast($_), @{$p->{holes}}
                ],
            );
        }
    }
    
    if ($Slic3r::debug) {
        Slic3r::debugf "Final surfaces (%d):\n", scalar @{ $self->surfaces };
        Slic3r::debugf "  [%s] %s (%s with %d holes)\n", $_->surface_type, $_->id, 
            ($_->contour->is_counter_clockwise ? 'ccw' : 'cw'), scalar @{$_->holes} for @{ $self->surfaces };
    }
}

sub remove_small_surfaces {
    my $self = shift;
    my @good_surfaces = ();
    
    foreach my $surface (@{$self->surfaces}) {
        next if !$surface->contour->is_printable;
        @{$surface->holes} = grep $_->is_printable, @{$surface->holes};
        push @good_surfaces, $surface;
    }
    
    @{$self->surfaces} = @good_surfaces;
}

sub remove_small_perimeters {
    my $self = shift;
    my @good_perimeters = grep $_->is_printable, @{$self->perimeters};
    Slic3r::debugf "removed %d unprintable perimeters\n", (@{$self->perimeters} - @good_perimeters) 
        if @good_perimeters != @{$self->perimeters};
    
    @{$self->perimeters} = @good_perimeters;
}

# make bridges printable
sub process_bridges {
    my $self = shift;
    return if $self->id == 0;
    
    # a bottom surface on a layer > 0 is either a bridge or a overhang 
    # or a combination of both
    
    my @bottom_surfaces     = grep $_->surface_type eq 'bottom',   @{$self->surfaces} or return;
    my @supporting_surfaces = grep $_->surface_type =~ /internal/, @{$self->surfaces};
    
    SURFACE: foreach my $surface (@bottom_surfaces) {
        # since we can't print concave bridges, we transform the surface
        # in a convex polygon; this will print thin membranes eventually
        my $surface_p = convex_hull($surface->contour->p);
        
        # find all supported edges (as polylines, thus keeping notion of 
        # consecutive supported edges)
        my @supported_polylines = ();
        {
            my @current_polyline = ();
            EDGE: foreach my $edge (Slic3r::Geometry::polygon_lines($surface_p)) {
                for (@supporting_surfaces) {
                    local $Slic3r::Geometry::epsilon = 1E+7;
                    if (Slic3r::Geometry::polygon_has_subsegment($_->contour->p, $edge)) {
                        push @current_polyline, $edge;
                        next EDGE;
                    }
                }
                if (@current_polyline) {
                    push @supported_polylines, [@current_polyline];
                    @current_polyline = ();
                }
            }
            push @supported_polylines, [@current_polyline] if @current_polyline;
        }
        
        # defensive programming, this shouldn't happen
        if (@supported_polylines == 0) {
            Slic3r::debugf "Found bridge/overhang with no supports on layer %d; ignoring\n", $self->id;
            next SURFACE;
        }
        
        if (@supported_polylines == 1) {
            Slic3r::debugf "Found bridge/overhang with only one support on layer %d; ignoring\n", $self->id;
            next SURFACE;
        }
        
        # now connect the first point to the last of each polyline
        @supported_polylines = map [ $_->[0]->[0], $_->[-1]->[-1] ], @supported_polylines;
        # @supported_polylines becomes actually an array of lines
        
        # if we got more than two supports, get the longest two
        if (@supported_polylines > 2) {
            my %lengths = map { $_ => Slic3r::Geometry::line_length($_) } @supported_polylines;
            @supported_polylines = sort { $lengths{"$a"} <=> $lengths{"$b"} } @supported_polylines;
            @supported_polylines = @supported_polylines[-2,-1];
        }
        
        # connect the midpoints, that will give the the optimal infill direction
        my @midpoints = map Slic3r::Geometry::midpoint($_), @supported_polylines;
        my $bridge_angle = -Slic3r::Geometry::rad2deg(Slic3r::Geometry::line_atan(\@midpoints) + PI/2);
        Slic3r::debugf "Optimal infill angle of bridge on layer %d is %d degrees\n", $self->id, $bridge_angle;
        
        # detect which neighbor surfaces are now supporting our bridge
        my @supporting_neighbor_surfaces = ();
        foreach my $supporting_surface (@supporting_surfaces) {
            local $Slic3r::Geometry::epsilon = 1E+7;
            push @supporting_neighbor_surfaces, $supporting_surface 
                if grep Slic3r::Geometry::polygon_has_vertex($supporting_surface->contour->p, $_), 
                    map $_->[0], @supported_polylines;
        }
        
        # defensive programming, this shouldn't happen
        if (@supporting_neighbor_surfaces == 0) {
            Slic3r::debugf "Couldn't find supporting surfaces on layer %d; ignoring\n", $self->id;
            next SURFACE;
        }
        
        # now, extend our bridge by taking a portion of supporting surfaces
        {
            # offset the bridge by the specified amount of mm
            my $bridge_offset = ${ offset([$surface_p], $Slic3r::bridge_overlap / $Slic3r::resolution, $Slic3r::resolution * 100, JT_MITER, 2) }[0];
            
            # calculate the new bridge
            my $clipper = Math::Clipper->new;
            $clipper->add_subject_polygon($surface_p);
            $clipper->add_subject_polygons([ map $_->p, @supporting_neighbor_surfaces ]);
            $clipper->add_clip_polygon($bridge_offset);
            my $intersection = $clipper->execute(CT_INTERSECTION, PFT_NONZERO, PFT_NONZERO);
            
            push @{$self->bridges}, map Slic3r::Surface::Bridge->cast_from_polygon($_,
                surface_type => 'bottom',
                bridge_angle => $bridge_angle,
            ), @$intersection;
        }
    }
}

# generates a set of surfaces that will be used to make perimeters
# thus, we need to merge internal surfaces and bridges
sub detect_perimeter_surfaces {
    my $self = shift;
    
    # little optimization: skip the Clipper UNION if we have no bridges
    if (!@{$self->bridges}) {
        push @{$self->perimeter_surfaces}, @{$self->surfaces};
    } else {
        my $clipper = Math::Clipper->new;
        $clipper->add_subject_polygons([ map $_->p, grep $_->surface_type =~ /internal/, @{$self->surfaces} ]);
        $clipper->add_clip_polygons([ map $_->p, @{$self->bridges} ]);
        my $union = $clipper->ex_execute(CT_UNION, PFT_NONZERO, PFT_NONZERO);
        
        push @{$self->perimeter_surfaces}, 
            map Slic3r::Surface->cast_from_expolygon($_, surface_type => 'internal'), 
            @$union;
        
        push @{$self->perimeter_surfaces}, 
            grep $_->surface_type !~ /internal/ && ($_->surface_type ne 'bottom' || $self->id == 0), 
            @{$self->surfaces};
    }
}

# splits fill_surfaces in internal and bridge surfaces
sub split_bridges_fills {
    my $self = shift;
    
    my $clipper = Math::Clipper->new;
    foreach my $surf_coll (@{$self->fill_surfaces}) {
        my @surfaces = @{$surf_coll->surfaces};
        @{$surf_coll->surfaces} = ();
        
        # intersect fill_surfaces with bridges to get actual bridges
        foreach my $bridge (@{$self->bridges}) {
            $clipper->clear;
            $clipper->add_subject_polygons([ map $_->p, @surfaces ]);
            $clipper->add_clip_polygon($bridge->contour->p);
            my $intersection = $clipper->ex_execute(CT_INTERSECTION, PFT_NONZERO, PFT_NONZERO);
            push @{$surf_coll->surfaces}, map Slic3r::Surface::Bridge->cast_from_expolygon($_,
                surface_type => 'bottom',
                bridge_angle => $bridge->bridge_angle,
            ), @$intersection;
        }
        
        # difference between fill_surfaces and bridges are the other surfaces
        foreach my $surface (@surfaces) {
            $clipper->clear;
            $clipper->add_subject_polygons([ $surface->p ]);
            $clipper->add_clip_polygons([ map $_->contour->p, @{$self->bridges} ]);
            my $difference = $clipper->ex_execute(CT_DIFFERENCE, PFT_NONZERO, PFT_NONZERO);
            push @{$surf_coll->surfaces}, map Slic3r::Surface->cast_from_expolygon($_,
                surface_type => $surface->surface_type), @$difference;
        }
    }
}

1;
